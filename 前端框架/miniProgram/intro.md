> 与小程序同学一起参与核心引擎的打造，一起共创小程序最前沿的技术规划，参与小程序API、组件的研发，以及打造最具服务体验的创意小程序。

1. 小程序的原理
1.1 微信和支付宝小程序的比较
	开发体验- 支付宝也应该像微信一样支持在桌面上查看调试日志，而非只能在手机上看
		是不是已经做到了？
		微信的开放者工具是基于 nw.js 的，那么支付宝的呢？

2. 小程序api
	本地存储的原理是如何实现的？
	能不能让小程序可以访问到当前版本号？
3. 小程序组件

模拟器的原理？

开发者写的所有代码最终将会打包成一份 JavaScript 脚本，在小程序启动的时候运行，在小程序结束运行时销毁。

由于框架并非运行在浏览器中， // 那是运行在哪里？

小程序在后台是如何维护的？

能否更有效地管理页面栈？
	每个有效页面都是一个render在维护，所以限制活动页面不能超过5个。但是页面栈的管理是否有更好的方式？

> 各个子页面通过全局函数 getApp() 可以获取全局的应用实例。
那么非页面的工具函数里可以获取到么？
	应该是可以的，因为util函数也会在页面中得到调用。最终js脚本又都是在同一个js bundle中跑的，所以应该是可以的。而且 getApp() 应该返回的就是 worker 维护的实例，应该是都可以访问到的。

onReady 时可以获取this了么？> 页面初次渲染完成时触发
	应该是可以的，这里的this应该是页面对应的实例。

> onLoad: 页面加载。一个页面只会调用一次，
所以页面在hide时，并没有销毁？什么操作导致页面 hide，什么导致unload？

> $spliceData同样用于将数据从逻辑层发送到视图层，但是相比于setData，在处理长列表的时候，其具有更高的性能。

$spliceData接受一个对象作为参数。
想来这个肯定是因为渲染和数据设置是割裂的，无法如react一样在render时设置key，所以只能用不能的方法来定量更新。

> 每个页面中的根元素为 page，

> 由于 data 为对象时为所有页面共享，因此如果该页面 back 后再次进入则显示为上一次的数据

> 那么当你输入 name 然后切换到 email 时，当前输入值会保留，如果不想保留，可以加 key

> on 事件绑定不会阻止冒泡事件向上冒泡，catch 事件绑定可以阻止冒泡事件向上冒泡。

> 运行原理
与传统的h5应用不同，小程序的运行从架构上分为 webview 和 worker 两个部分。webview 负责渲染，worker 则负责存储 数据 和执行 业务逻辑。

而 webview 和 worker 之间的通信是异步的。这意味着当我们调用 setData 时，我们的 数据 并不会立即得到渲染，而是需要从 worker 异步传输到 webview。
数据传输时需要序列化为字符串，然后通过 evaluateJavascript 的方式传输。这意味着数据的大小会影响性能。

控制小程序资源包大小
当用户访问一个小程序时，支付宝客户端会首先从 cdn 上下载小程序资源包，因此资源包大小会影响小程序的启动性能。

优化建议:

及时删除没有用的图片资源（所有图片资源都会默认打包进去）
控制图片的大小，不要使用大图片（稍大点的图片建议走cdn）
及时清理无用的代码
将数据请求提前到 onLoad
小程序运行时，会先触发页面的 onLoad 生命周期函数，然后将页面的初始数据（Page的 data）从 worker传递到 webview进行一次初始渲染，等待页面初始渲染完成之后，才会从 webview 发出通知到 worker，此时才会触发 onReady 生命周期函数。

当业务请求回来后，通常会调用 setData 触发页面的重新渲染。内部的执行过程如下:

数据从 worker 传递到 webview
webview 上根据传过来的数据构造虚拟dom，并与之前做 diff（从根节点开始），然后渲染。
由于 worker与 webview 通信时，数据需要序列化，然后到了 webview 需要执行 evaluateJavascript，因此如果一次性传输很大的数据，会影响首屏渲染的性能。

setData
setData大概是小程序中使用最为频繁的接口了，因为页面上的任何变化都需要其去触发，但是能够触发页面去重新渲染的却不止一个 setData。如下四个接口都会触发 webview 上页面的重新渲染。

Page.prototype.setData: 触发整个页面做diff
Page.prototype.$spliceData: 针对长列表做优化，避免每次传递整个列表，触发整个页面做diff
Component.prototype.setData: 只会从对应组件节点开始做diff
Component.prototype.$spliceData: 针对长列表做优化，避免每次传递整个列表，只会从对应组件节点开始做diff














微信小程序

实现逻辑部分的JS还是通用的ES规范，并没有什么不同，并且runtime还是Webview（IOS WKWEBVIEW, ANDROID X5）


这就涉及到这个编辑器的实现原理和方式了，它本身也是基于WEB技术体系实现的，nwjs+react，nwjs是什么：简单是说就是node+webkit，node提供给我们本地api能力，而webkit提供给我们web能力，两者结合就能让我们使用JS+HTML实现本地应用程序。







所有的小程序基本都最后都被打成上面的结构
1、WAService.js  框架JS库，提供逻辑层基础的API能力
2、WAWebview.js 框架JS库，提供视图层基础的API能力
3、WAConsole.js 框架JS库，控制台
4、app-config.js 小程序完整的配置，包含我们通过app.json里的所有配置，综合了默认配置型
5、app-service.js 我们自己的JS代码，全部打包到这个文件
6、page-frame.html 小程序视图的模板文件，所有的页面都使用此加载渲染，且所有的WXML都拆解为JS实现打包到这里
7、pages 所有的页面，这个不是我们之前的wxml文件了，主要是处理WXSS转换，使用js插入到header区域


小程序的UI视图和逻辑处理是用多个线程实现的，逻辑处理的JS代码全部加载到一个worker里面，称之为AppService，整个小程序只有一个，并且整个生命周期常驻内存，而所有的视图（wxml和wxss）都是单独的render来承载，称之为AppView。所以一个小程序打开至少就会有2个线程，正式因为每个视图都是一个独立的render，考虑到性能消耗，小程序不允许打开超过5个层级的页面，当然同是也是为了体验更好
（每个render是不是一个独立的线程？）


脱离了浏览器，JS 自然没有 dom 的调用权限，任何跟 webview 界面相关的 API 都无法拿到。而小程序框架核心JS运行在webview上，可以自由操作dom，通过小程序框架定义的机制，应用端通过 wxml/wxss 定义固定的渲染样式，JS 端只管数据绑定，数据可以通过 native 桥梁从 JS 引擎传递到 webview，JS端无法做任何渲染相关的操作，可以对渲染的内容有完整的管控权。

独立的 JS 运行环境除了满足管控需求外，也额外带来一些好处和一些坏处，好处在于：

多个页面可以共享一个 JS 运行环境，数据可以很方便地共享，整个小程序生命周期里共享同一个上下文，更接近 APP 的开发体验。
JS 与页面渲染分离并行执行，不会出现 JS 执行时卡住页面渲染的情况，提升渲染性能。








我们先看下小程序框架大图，自上而下看。

小程序代码：这是小程序开发者使用小程序 DSL 及各种组件开发的小程序。
小程序组件及 API：这是小程序的组件及 API 层，提供了小程序所需的各种组件和小程序 API。小程序开发者只需要在基于这一层提供的组件及 API 进行小程序的开发。
小程序应用层框架：这是小程序运行的框架层，它基于 React 实现了小程序的运行框架。该层主要包含小程序的逻辑处理引擎及渲染层。
Native SDK：该层提供了小程序所需的 Native 能力，通过J avaScriptCore 为小程序的 JS 层框架提供大量的 Native API，此外该层还提供了小程序包管理、后台保活等基础能力。
React 和 React Native：这一层是小程序底层运行环境，分别对应于 Web 和 Native 环境，使得小程序可运行在 WebView 和 iOS/Android 上。
系统层：即 Web 内核、iOS 和 Android，是系统级的平台层。

作者：蚂蚁金服移动开发平台mPaaS
链接：https://juejin.im/post/5c01f24b51882511a852a404
来源：掘金
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

每个小程序的代码分为两部分——逻辑处理和视图渲染，分别运行在 worker （js 引擎） 以及 render （渲染层）中。

worker 运行小程序的逻辑处理代码，包括事件处理，api 调用以及框架的生命周期管理。 worker 只有一个，方便 App 数据在页面间的共享和交互。
render 运行小程序的渲染代码，主要包括模版、样式和框架的跨终端的 js 组件或 native 组件，获取逻辑层的数据操作渲染引擎（React/ReactNative）进行渲染，render 在小程序中可以有多个。
worker 和所有的 render 都建立连接，将需要渲染的数据传递给对应的 render 进行渲染，worker 也会将 api 调用转给 Native SDK 处理。
render 则将组件的触发事件送到对应的 worker 处理，同时接受 worker 的调用进行重新渲染。 render 可以看作一个无状态的渲染终端，小程序的状态都保留在 worker 内。

作者：蚂蚁金服移动开发平台mPaaS
链接：https://juejin.im/post/5c01f24b51882511a852a404
来源：掘金
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

Webview 渲染是 React；原生渲染是 RN。Nebula 是 H5 容器，负责小程序 Native SDK 这一层。




按照小程序的指示图，onload和onshow/onhide/onunload等方法都是在appservice线程上触发和执行的。那么是一个view对应一个appservice，还是多个view对应一个appservice呢？如果是多对一，那么就是appservice通知当前的view执行对应方法？还是根据view的不同appservice会加载不同的方法？


小程序里给一个空的 setdata 会不会重新渲染？