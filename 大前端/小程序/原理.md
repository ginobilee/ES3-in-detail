原理

可以将小程序的运行时框架分为两块，负责逻辑处理的worker和负责渲染页面的render。每个页面都有一个render，不同的render都与worker保持联系。
应用的生命周期/api调用等放在worker中处理，方便多页面共享数据。
worker将要渲染的数据传给render进行渲染；render执行虚拟树的建立，输出渲染树，再放在webview中渲染。
worker和render之间不可以直接通信，而要通过一个jsbridge。这是为了防止用户直接操作dom，将数据操作与页面显示隔离开。同时隔离开后，执行用户端的处理逻辑也不会再阻塞渲染render进行树生成。
两者有事件或通知时都是通过jsbridge来互通消息。
JS 逻辑代码与页面渲染分离并行执行，不会出现 JS 代码执行时卡住页面渲染的情况，进而提升渲染性能。多个页面可以共享一个 JS 运行环境，数据可以很方便地共享，整个小程序生命周期里共享同一个上下文，更接近 App 的开发体验



<blockquote>
在 Android 里，js 调用 native 的通讯是通过 console.log 的方式，这个和其他容器实现不一样，其他容器一般通过 prompt 的方式来实现的，但是使用 prompt 的方式，有两个弊端：

使用 prompt 会阻断整个浏览器的进程，如果 native 处理时间一长，会导致页面假死。
prompt 是在 UI 层面上会弹出一个模态窗口，在 native 没有对其进行捕获处理的话，会造成一个问题。一旦这个页面放在非此容器的环境下，就会出现一个很诡异的 prompt 弹窗。在支付宝内，曾经出现过这个问题，天猫页面在支付宝 app 里的时候，由于容器机制不同，页面中 bridge 脚本没有判断环境，导致页面中 js 调用 API 的时候，在页面上出现了 prompt 的模态对话框，严重影响了用户体验，但是如果使用 console.log 的话，就不会出现这个问题。console 的方式避免了不兼容环境的体验问题和同时也避免了页面的假死。



在 Neblua 中我们使用离线包技术来解决这个问题。离线包是将包括 HTML、Javascript、CSS 等页面内静态资源打包到一个压缩包内，它的目录结构如图所示：


实现动态更新：在推出新版本或是紧急发布的时候，您可以把修改的资源放入离线包，通过更新配置让应用自动下载更新。因此，您无需通过应用商店审核，就能让用户及早接收更新。
</blockquote>
https://juejin.im/post/5bd3f516518825279a5f9694