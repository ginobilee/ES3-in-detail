模块化

## CommonJS
Node应用的默认模块管理机制。
每个文件就是一个模块，有自己的作用域。在一个文件里面定义的变量、函数、类，都是私有的，对其他文件不可见。在服务器端，模块的加载是运行时同步加载的；在浏览器端，模块需要提前编译打包处理。

### 特点
模块加载是同步的
模块可以多次加载，但是只会在第一次加载时运行一次，然后运行结果就被缓存了，以后再加载，就直接读取缓存结果。要想让模块再次运行，必须清除缓存。
模块加载的顺序，按照其在代码中出现的顺序。

### 加载
require命令用于加载模块文件。require命令的基本功能是，读入并执行一个JavaScript文件，然后返回该模块的exports对象。如果没有发现指定模块，会报错。

### 加载机制
CommonJS模块的加载机制是，**输入的是被输出的值的拷贝。也就是说，一旦输出一个值，模块内部的变化就影响不到这个值。这点与ES6模块化有重大差异（下文会介绍）**

### 浏览器端使用
在浏览器上，需要借助browserify将app.js文件打包编译，如果直接在index.html引入app.js就会报错

## AMD
浏览器端一般采用AMD规范, 非同步加载
主要价值就是给浏览器端提供了一种实现异步加载依赖的方案。
```
//定义没有依赖的模块
define(function(){
   return 模块
})
```

```
//定义有依赖的模块
define(['module1', 'module2'], function(m1, m2){
   return 模块
})
```

```
// 引入使用模块
require(['module1', 'module2'], function(m1, m2){
   使用m1/m2
})
```


## CMD
CMD规范专门用于浏览器端，模块的加载可以是异步的，**使用时才会加载执行**。CMD规范整合了CommonJS和AMD规范的特点。在 Sea.js 中，***所有 JavaScript 模块都遵循CMD模块定义规范***。

即，除了在引入脚本时使用`seajs.use('./js/modules/main')`外，即使是主入口文件也是使用`define()`语法加载依赖和执行代码，只是在这里不再输出模块了。

## ES6
设计思想是尽量的静态化，使得编译时就能确定模块的依赖关系，以及输入和输出的变量。CommonJS 和 AMD 模块，都只能在运行时确定这些东西。比如，CommonJS 模块就是对象，输入时必须查找对象属性。

### 与 CommonJS 模块的差异
① ***CommonJS 模块输出的是一个值的拷贝，ES6 模块输出的是值的引用。***ES6 模块是动态引用，并且不会缓存值，模块里面的变量绑定其所在的模块。
② CommonJS 模块是运行时加载，ES6 模块是编译时输出接口。

第二个差异是因为 CommonJS 加载的是一个对象（即module.exports属性），该对象只有在脚本运行完才会生成。而 ES6 模块不是对象，它的对外接口只是一种静态定义，在代码静态解析阶段就会生成。

ES6 在语言标准的层面上，实现了模块功能，而且实现得相当简单，完全可以取代 CommonJS 和 AMD 规范，成为浏览器和服务器通用的模块解决方案

## 对于循环引用的处理的区别

### CommonJS
CommonJS模块的重要特性是加载时执行，即脚本代码在require的时候，就会全部执行。
对于循环依赖，CommonJS的做法是，一旦出现某个模块被"循环加载"，就只输出已经执行的部分，还未执行的部分不会输出。

### es6
只是引用，所以对于循环依赖没有任何影响，直接去调用就好。


参考：
https://juejin.im/post/5c17ad756fb9a049ff4e0a62
http://www.ruanyifeng.com/blog/2015/11/circular-dependency.html