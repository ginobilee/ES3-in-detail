# what
当分配的内存在程序不需要后未被释放，即形成了内存泄漏。

# how gc works
以前的做法是引用计数。对引用进行计数，当计数为0时清除之。这种算法的弊端是当产生循环引用时无法被gc清除。

现在在js中，通用的做法是*引用判断*。如果一个变量已经在当前环境中判断为*unreachable*，那么它就会被回收。所以es6在运行环境中规范了realm概念，一个运行环境中有一个独立的realm，它维持一个独立的全局对象，对于垃圾回收也是有益处的吧？

# cases
1. 将变量挂载全局变量上
2. 为节点挂载handler后未及时清空
3. 闭包中的未清除的无用引用
4. dom节点引用。如果将某个dom节点存在在程序的变量中，即使文档中已经删除这个节点，程序还是会保留对它的引用。


# what should be done
1. 避免将变量声明在全局对象上。如果必须，那么在用完后null之。
2. 当节点不需要handler或节点将从文档中移除时，取消掉handler的引用。
3. 清楚闭包中不再使用的引用
4. 清空无用的dom节点。