

> 当创建一个 web 应用的时候，参考 [PRPL 模式](https://link.juejin.im/?target=https%3A%2F%2Fdevelopers.google.com%2Fweb%2Ffundamentals%2Fperformance%2Fprpl-pattern%2F) 和 [应用程序 shell 体系结构](https://link.juejin.im/?target=https%3A%2F%2Fdevelopers.google.com%2Fweb%2Fupdates%2F2015%2F11%2Fapp-shell)。这个想法很简单: 用最少的代码来将初始路由的交互快速呈现，然后使用 service worker 进行缓存和预缓存资源，然后使用懒加载异步加载所需的路由。

> ### 速效方案
>
> 这个列表非常全面，完成所有的优化可能需要很长时间。所以，如果你只有一个小时的时间来进行重大的改进，你会怎么做？让我们把这一切归结为**10个低挂的水果**。显然，在你开始之前和完成之后，测量结果，包括开始渲染时间以及在 3G 和电缆连接下的速度指数。
>
> 1. 测量实际环境的体验并设定适当的目标。一个好的目标是：第一次有意义的绘制 < 1 s，速度指数 < 1250，在慢速的 3G 网络上的交互 < 5s，对于重复访问，TTI < 2s。优化渲染开始时间和交互时间。
> 2. 为您的主模板准备关键的 CSS，并将其包含在页面的 `<head>` 中。（你的预算是 14 KB）。对于 CSS/JS，文件大小[不超过 170 KB gzipped](https://link.juejin.im?target=https%3A%2F%2Finfrequently.org%2F2017%2F10%2Fcan-you-afford-it-real-world-web-performance-budgets%2F)（解压后 0.8-1 MB）。
> 3. 延迟加载尽可能多的脚本，包括您自己的和第三方的脚本——特别是社交媒体按钮、视频播放器和耗时的 JavaScript 脚本。
> 4. 添加资源提示，使用 `dns-lookup`、`preconnect`、`prefetch` 和 `preload` 加速传输。
> 5. 分离 web 字体，并以异步方式加载它们（或切换到系统字体）。
> 6. 优化图像，并在重要页面（例如登录页面）中考虑使用 WebP。
> 7. 检查 HTTP 缓存头和安全头是否设置正确。
> 8. 在服务器上启用 Brotli 或 Zopfli 压缩。（如果做不到，不要忘记启用 Gzip 压缩。）
> 9. 如果 HTTP/2 可用，启用 HPACK 压缩并开启混合内容警告监控。如果您正在运行 LTS，也可以启用 OCSP stapling。
> 10. 在 service worker 缓存中尽可能多的缓存资产，如字体、样式、JavaScript 和图像。

[Debugging React performance with React 16 and Chrome Devtools.](https://building.calibreapp.com/debugging-react-performance-with-react-16-and-chrome-devtools-c90698a522ad)


### 前端性能优化的不同范畴：

1. 首屏加载/渲染速度
    1.1 首页文件体积
        压缩css和js
    1.2 首页中的脚本和css
        [把样式放在顶部。

        研究雅虎网页性能时发现把样式表移到里会让页面更快。这是因为把样式表移到里允许页面逐步渲染。

        关注性能的前端工程师希望页面被逐步渲染，这时因为，我们希望浏览器尽早渲染获取到的任何内容。这对大页面和网速慢的用户很重要。给用户视觉反馈，比如进度条的重要性已经被大量研究和记录。在我们的情况中，HTML页面就是进度条。当浏览器逐步加载页面头部，导航条，logo等等，这些都是给等待页面的用户的视觉反馈。这优化了整体用户体验。

        把样式表放在文档底部的问题是它阻止了许多浏览器的逐步渲染，包括IE。这些浏览器阻止渲染来避免在样式更改时需要重绘页面元素。所以用户会卡在白屏。

        HTML规范清楚表明样式应该在里。]

        [把脚本放到底部。

        脚本引起的问题是**它们阻塞了并行下载**。HTTP1.1规范建议浏览器每个域名下不要一次下载超过2个组件。如果你的图片分散在不同服务器，那么你能并行下载多个图片。但当脚本在下载，浏览器不会再下载其它组件，即使在不同域名下。]
        [删除重复脚本]
    1.3 首页中的ajax请求
      [雅虎军规1.1](Make Fewer HTTP Requests
        Minimize HTTP Requests减少/最小化 http 请求数。

        到终端用户的响应时间80%花在前端：大部分用于下载组件（js/css/image/flash等等）。减少组件数就是减少渲染页面所需的http请求数。这是更快页面的关键。

        减少组件数的一个方法就是简化页面设计。保持富内容的页面且能减少http请求，有以下几个技术：

        Combined files。合并文件，如合并js，合并css都能减少请求数。如果页面间脚本和样式差异很大，合并会更具挑战性。
        CSS Sprites。雪碧图可以合并多个背景图片，通过background-image 和 background-position 来显示不同部分。
        Image maps。合并多个图片到一个图片，一般用于如导航条。由于定义坐标的枯燥和易错，一般_不推荐_。
        Inline images。使用data:url scheme来內连图片。
        减少请求数是为第一次访问页面的用户提高性能的最重要的指导。
    1.4 减少DNS查询。
        就像电话簿，你在浏览器地址栏输入网址，通过DNS查询得到网站真实IP。

        DNS查询被缓存来提高性能。这种缓存可能发生在特定的缓存服务器（ISP/local area network维护），或者用户的计算机。DNS信息留存在操作系统DNS缓存中（在windows中就是 DNS Client Serve ）。大多浏览器有自己的缓存，独立于操作系统缓存。只要浏览器在自己的缓存里有某条DNS记录，它就不会向操作系统发DNS解析请求。

        IE默认缓存DNS记录30分钟，FireFox默认缓存1分钟。

        当客户端的DNS缓存是空的，DNS查找次数等于页面中的唯一域名数。

        减少DNS请求数可能会减少并行下载数。避免DNS查找减少响应时间，但减少并行下载数可能会增加响应时间。*指导原则是组件可以分散在至少2个但不多于4个的不同域名。这是两者的妥协。*(利用多域名来增加并行请求数与多域名解析耗时的矛盾)
    1.5 避免跳转。

        跳转用301或302状态码来达成。一个301响应http头的例子：

        HTTP/1.1 301 Moved Permanently
        Location: http://example.com/newuri
        Content-Type: text/html
        浏览器自动跳转到Location指定的路径。跳转所需的所有信息都在http头，所以http主体一般是空的。301302响应一般不会被缓存，除非有额外的头部信息，比如Expires或Cache-Control指定要缓存。meta刷新标签或 JavaScript 也可以跳转，但如果真要跳转，3xx跳转更好，主要是保证返回键可用。

        跳转显然拖慢响应速度。在跳转的页面被获取前浏览器没什么能渲染，没什么组件能下载。

        最浪费的跳转之一发生在url尾部slash（/）缺失。比如http://astrology.yahoo.com/astrology会301跳转到http://astrology.yahoo.com/astrology/。这可以被Apache等服务器修复，用Alias，mod\_rewrite等等。
    1.6 让Ajax可缓存。

        使用ajax的好处是可以向用户提供很快的反馈，因为它是向后台异步请求数据。但是，这些异步请求不保证用户等待的时间——异步不意味着瞬时。

        提高ajax性能的最重要的方法是让响应被缓存，即在Add an Expires or a Cache-Control Header中讨论的 Expires 。
    1.7 延迟加载组件。

        再看看你的页面然后问问自己，“什么是页面初始化必须的？”。剩下的内容和组件可以延迟。

        JavaScript是理想的（延迟）候选者，可以切分到onload事件之前和之后。比如拖放的js库可以延迟，因为拖动必须在页面初始化之后。其它可延迟的包括隐藏的内容，折叠起来的图片等等。
    1.8 预加载组件。

        预加载看起来与延迟加载相反，但它的确有个不同的目标。通过预加载你可以利用浏览器的空闲时间来请求你将来会用到的组件。这样当用户访问下一个页面时，你会有更多的组件已经在缓存中，这样会极大加快页面加载。

        有几种预加载类型：

        无条件预加载：一旦onload触发，你立即获取另外的组件。比如谷歌会在主页这样加载搜索结果页面用到的雪碧图。
        有条件预加载：基于用户动作，你推测用户下一步会去哪里并加载相应组件。
        预期的预加载：在发布重新设计（的网站）前提前加载。在旧网页预加载新网页的部分组件，那么切换到新网页时就不会是没有任何缓存了。
    1.9 减少dom数。

        一个复杂的页面意味着更多的内容要下载，以及更慢的dom访问。比如在有500dom数量的页面添加事件处理就和有5000dom数量的不同。

        如果你的页面dom元素很多，那么意味着你可能需要删除无用的内容和标签来优化。
    1.10 把组件分散到不同的域名。

        把组件分散到不同的域名允许你最大化并行下载数。由于DNS查询的副作用，最佳的不同域名数是2-4。
    1.11 不要404。

        http请求是昂贵的，所以发出http请求但获得没用的响应（如404）是完全不必要的，并且会降低用户体验。

        一些网站会有特别的404页面提高用户体验，但这仍然会浪费服务器资源。特别坏的是当链接指向外部js但却得到404结果。这样首先会降低（占用）并行下载数，其次浏览器可能会把404响应体当作js来解析，试图从里面找出可用的东西。
    1.12 传输时用gzip等压缩组件。

        gzip一般可减小响应的70%。尽可能去gzip更多（文本）类型的文件。html，脚本，样式，xml和json等等都应该被gzip，而图片，pdf等等不应该被gzip，因为它们本身已被压缩过，gzip它们只是浪费cpu，甚至增加文件大小。
    1.13 首页中的图像
        1.13.1 优化图片

                在设计师建好图片后，在上传图片到服务器前你仍可以做些事：

                检查gif图片的调色板大小是否匹配图片颜色数。
                可以把gif转成png看看有没有变小。除了动画，gif一般可以转成png8。
                运行pngcrush或其它工具压缩png。
                运行jpegtran或其它工具压缩jpeg。
        1.13.2 优化CSS雪碧图

                把图片横向合并而不是纵向，横向更小。
                把颜色近似的图片合并到一张雪碧图，这样可以让颜色数更少，如果低于256就可以用png8.
                "Be mobile-friendly"并且合并时图片间的间距不要太大。这对图片大小影响不是太大，但客户端解压时需要的内存更少。100×100是10000个像素，1000×1000是1000000个像素。
        1.13.3 不要在html中缩放图片

                不要因为你可以设置图片的宽高就去用比你需要的大得多的图片。如果你需要

                <img width="100" height="100" src="mycat.jpg" alt="My Cat" /> 
                那么，就用100x100px的图片，而不是500x500px的。
        1.13.4 favicon.ico小且缓存

                favicon.ico是在你服务器根路径的图片。邪恶的是即使你不关心它，浏览器仍然会请求它。所以最好不要响应404。另外由于在同一服务器，每次请求favicon.ico时也会带上cookie。这个图片还会影响下载顺序，比如在IE，如果你在onload时下载额外的组件，fcvicon会在这些组件之前被下载。

                怎么减轻favicon.ico的缺点？

                小，最好1K以下
                设置Expires头部。也许可以安全地设置为几个月。
2. 页面响应操作/重绘性能
    采用现代的前端框架如react、vue，它们已经对前端的重绘性能进行很大程度的优化，比如 virtual dom。开发者在开发中应该注意的首先是遵从所采用框架的最佳实践，比如对于react，经典的优化点 *1. 在shouldComponentUpdate中进行数据检测，对于不需更新的时候返回false(或结合immutable.js使用pureComponent); 2. 对于列表或同类子组件使用key*。在懂得框架的运行原理的情况下，针对性地在代码中优化性能。
    在没有采用框架的代码中，就要遵循高性能的js代码原则，如： 
    A. 最小化DOM访问。

        用JS访问DOM元素是缓慢的，所以为了响应更好的页面，你应该：

        缓存访问过的元素的引用
        在DOM树外更新节点，然后添加到DOM树
        避免用JS实现固定布局
    B. 避免反复对dom中的元素/属性/样式进行读写操作，尽量批处理操作；
    C. 对高频触发的事件进行节流或消抖。
    D. 开发聪明的事件处理

      有时候页面看起来不那么响应（响应速度慢），是因为绑定到不同元素的大量事件处理函数执行太多次。这是为什么使用_事件委托_是一种好方法。

      另外，你不必等到onload事件来开始处理DOM树，DOMContentLoaded更快。大多时候你需要的只是想访问的元素已在DOM树中，所以你不必等到所有图片被下载
3.  移动端
    3.1 保持组件小于25K

        这个限制与iPhone不缓存大于25K的组件相关。注意，这是非压缩（uncompressed）的文件大小。在这里minification（压缩，不要与compress混淆）很重要，因为gzip无法满足（iPhone）。
    3.2 打包组件到一个多部父文档

        打包组件到一个多部父文档类似于带附件的邮件。它帮助你在一个http请求中获取多个组件，但注意，iPhone不支持。
        
4. 安全性能

### 如何检测当前的前端性能？
1. 加载：直观感觉+chrom devtools分析
2. 重绘：用devtools分析。

### 确定一个性能优化的目标
1. 首先从影响性能最严重的点上着手。比如是文件体积、图片体积等等。
2. 用工具分析制约性能的点。常用工具devtools。
3. 从战略上，可以研究用新的技术改善性能。比如pwa。

### 要不要使用e-tag?
  ETag的问题是它们被构造来使它们对特定的运行这个网站的服务器唯一。浏览器从一个服务器获取组件，之后向另一个服务器验证，ETag将不匹配。然而服务器集群是处理请求的通用解决方案。

  如果不能解决多服务器间的ETag匹配问题，那么删除ETag可能更好。

### 用没有cookie的域名提供组件。

当浏览器请求静态图片并把cookie一起发送到服务器时，cookie此时对服务器没什么用处。所以这些cookie只是增加了网络流量。所以你应该保证静态组件的请求是没有cookie的。可以创建一个子域名来托管所有静态组件。

比如，你域名是www.example.org，可以把静态组件托管在static.example.org。不过，你如果把cookie设置在顶级域名example.org下，这些cookie仍然会被传给static.example.org。这种情况下，启用一个全新的域名来托管静态组件。

另外一个用没有cookie的域名提供组件的好处是，某些代理可能会阻止缓存待cookie的静态组件请求。