


### 为什么 DOM 很慢

这里需要对浏览器利用 HTML/CSS/JavaScript 等资源呈现出精彩的页面的过程进行简单说明。浏览器在收到 HTML 文档之后会对文档进行解析开始构建 DOM (Document Object Model) 树，进而在文档中发现样式表，开始解析 CSS 来构建 CSSOM（CSS Object Model）树，这两者都构建完成后，开始构建渲染树。

在每次修改了 DOM 或者其样式之后都要进行 DOM树的构建，CSSOM 的重新计算，进而得到新的渲染树。浏览器会利用新的渲染树对页面进行重排和重绘，以及图层的合并。通常浏览器会批量进行重排和重绘，以提高性能。但当我们试图通过 JavaScript 获取某个节点的尺寸信息的时候，为了获得当前真实的信息，浏览器会立刻进行一次重排。

### 避免强制性同步布局

在 JavaScript 中读取到的布局信息都是上一帧的信息，如果在 JavaScript 中修改了页面的布局，比如给某个元素添加了一个类，然后再读取布局信息。这个时候为了获得真实的布局信息，浏览器需要强制性对页面进行布局。因此应该避免这样做。

### 优化渲染性能

浏览器通常每秒更新页面 60 次，每一帧的时间就是 16.6ms，为了能让浏览器保持 60帧 的帧率，为了让动画看起来流畅，需要保证帧率达到 60fps，因此每一帧的逻辑需要在 16.6ms 内完成。

每一帧实际上都包含下列步骤：
! [每一次重绘的步骤] (https://camo.githubusercontent.com/b972f55cd4ca600684f3cf5aa39c3beead6254e0/687474703a2f2f3778733167752e636f6d312e7a302e676c622e636c6f7564646e2e636f6d2f31362d392d32342f39323637313232392e6a7067)

因此，通常 JavaScript 的执行时间不能超过 10ms。

JavaScript：改变元素样式，添加元素到 DOM 中等等
Style：元素的类或者style改变了，这个时候需要重新计算元素的样式
Layout：需要重新计算元素的具体尺寸
Paint：将元素的绘制的图层上
Composite：合并多个图层
当然也不是说每一帧都会进行这些操作。当你的 JavaScript 改变了某个 layout 属性，比如元素的 width 和 height 或者 top 等等，浏览器就会重新计算布局，并对整个页面进行重排。

如果修改了 background、color 这样的仅仅会让页面重绘的属性，这不会影响页面的布局，浏览器会跳过计算布局（layout）的过程，只进行重绘（paint）。

如果修改了一个不需要计算布局也不需要重绘的属性，那就只会进行图层的合并，这是代价最小的修改。从 https://csstriggers.com/ 上你可以知道修改那些样式属性会触发（Layout，Paint，Composite）中的那些操作。

使用 transform 和 opacity 来完成动画
如今只有对这两个属性的修改不需要经历 layout 和 paint 过程。

### 对高频触发的事件进行节流或消抖
对于 Scroll 和 Touchmove 这类事件，永远不要低估了它们的执行频率，处理这类事件的时候可以考虑是否要给它们添加一个节流或者消抖过的回调。节流和消抖，可能其他人不这么翻译，其实也就是 debounce 和 throttle 这两个函数。

debounce 和 throttle 是两个相似（但不相同）的用于控制函数在某段事件内的执行频率的技术。你可以在 underscore 或者 lodash 中找到这两个函数。

#### 使用 debounce 进行消抖
多次连续的调用，最终实际上只会调用一次。想象自己在电梯里面，门将要关上，这个时候另外一个人来了，取消了关门的操作，过了一会儿门又要关上，又来了一个人，再次取消了关门的操作。电梯会一直延迟关门的操作，直到某段时间里没人再来。

所以 debounce 适合用在比如对用户输入内容进行校验的这种场景下，多次触发只需要响应最后一次触发就好了。

####使用 throttle 进行节流
将频繁调用的函数限定在一个给定的调用频率内。它保证某个函数频率再高，也只能在给定的事件内调用一次。比如在滚动的时候要检查当前滚动的位置，来显示或隐藏回到顶部按钮，这个时候可以使用 throttle 来将滚动回调函数限定在每 300ms 执行一次。

需要提到的是，这两个函数常常被误用，且很多时候当事人并没有意识到自己误用了。我曾经用错过，也见过别人用错。这两个函数都接受一个函数作为参数，然后返回一个节流/去抖后的函数，下面第二种用法才是正确的用法：

// 错误的用法，每次事件触发都得到一个新的函数
$(window).on('scroll', function() {
   _.throttle(doSomething, 300);
});

// 正确的用法，将节流后的函数作为回调
$(window).on('scroll', _.throttle(doSomething, 200));
